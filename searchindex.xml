<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>docker.sock connect</title><url>/post/docker/docker-sock/</url><categories><category>docker</category></categories><tags><tag>docker</tag></tags><content type="html"> 目录 任务失败 解决方案 总结 任务失败 远程派发了一个任务启动一个容器，竟然失败了，平时都没有出现过问题。通过日志查看发现问题如下：
==++Got++ permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get &ldquo;http://%2Fvar%2Frun%2Fdocker.sock/v1.24/containers/json?all=1" : dial unix /var/run/docker.sock: connect: permission denied==
我擦，竟然没有权限。赶紧查看了下docker.socker权限
$ ll /var/run/docker.sock srw-rw----. 1 root docker 0 Dec 13 02:09 /var/run/docker.sock 权限模式为srw-rw&mdash;-，所属用户为root，所属组为docker。问题也明确了，这次派发的任务用户不是root才导致问题的发生
解决方案 既然找到了问题，那就好解决了，按如下步骤操作即可
当前用户加入docker所属组 $sudo gpasswd -a $USER docker # 或 $sudo usermod -a -G docker $USER 给用户权限 查看docker.socket配置 $vi /usr/lib/systemd/system/docker.socket [Unit] Description=Docker Socket for the API [Socket] ListenStream=/var/run/docker.sock SocketMode=0660 SocketUser=root SocketGroup=docker [Install] WantedBy=sockets.target 修改SocketMode=0666就好了 3. 修改生效 修改并保存完成后，重新加载守护并重启socket
$sudo systemctl daemon-reload $sudo systemctl restart docker.socket 再使用docker命令就不会报错了。
总结 介绍了使用docker命令时发现docker.sock: connect: permission denied权限问题和解决思路。</content></entry><entry><title>docker容器PID</title><url>/post/docker/container-pid/</url><categories><category>docker</category></categories><tags><tag>docker</tag></tags><content type="html"> 查找docker容器的PID 平时操作容器都是通过容器ID直接操作，例如docker exec -it containerID。可我们也知道docker的容器本身就是一个进程，那怎么通过容器ID查找容器的进程PID呢？
下面主要介绍三种方法： 使用ps命令查找 $docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES b44a0186085e ubuntu:15.10 "/bin/bash" 26 seconds ago Up 25 seconds ubuntu0 c40f77fe3abf ubuntu:15.10 "/bin/bash" 2 days ago Up 2 days ubuntu1 $ps aux|grep b44a0186085e root 47640 0.0 0.1 712432 6240 ? Sl 03:14 0:00 /usr/bin/containerd-shim-runc-v2 -namespace moby -id b44a0186085e115a7a666eb1533af066e694dddfa25022754567b7f31c214316 -address /run/containerd/containerd.sock 先通过docker ps查找容器ID是b44a0186085e, 再通过ps查找PID是47640
使用docker inspect查找 $docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES b44a0186085e ubuntu:15.10 "/bin/bash" 5 minutes ago Up 5 minutes ubuntu0 c40f77fe3abf ubuntu:15.10 "/bin/bash" 2 days ago Up 2 days ubuntu1 $docker inspect -f '{{.State.Pid}}' b44a0186085e 47662 $ps -ef|grep 47662 root 47662 47640 0 03:14 pts/0 00:00:00 /bin/bash docker inspect -f过滤出容器运行的命令的PID是47662, 这个PID和上面的不一样，其实这个PID是容器命令bash的PID,就是上面pid的子进程的PID, 通过ps -ef能清楚的看到
使用docker container top 查找 $docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES b44a0186085e ubuntu:15.10 "/bin/bash" 18 minutes ago Up 18 minutes ubuntu0 c40f77fe3abf ubuntu:15.10 "/bin/bash" 2 days ago Up 2 days ubuntu1 $docker container top b44a0186085e UID PID PPID C STIME TTY TIME CMD root 47662 47640 0 03:14 pts/0 00:00:00 /bin/bash docker container top能够看到容器的PID是47640， 运行了一个bash程序，进程PID是47662 通过容器的top命令，也能够清晰的看到容器中所有进程关系
总结 介绍了三种方法查找容器的PID
ps aux|grep 容器ID docker inspect 容器ID docker container top 容器ID</content></entry><entry><title>grpc的简介和使用</title><url>/post/golang/grpc/</url><categories><category>golang</category></categories><tags><tag>golang</tag></tags><content type="html"> gRPC(google+remote process call) 详解 grpc 简介 grpc是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。所谓RPC(remote procedure call 远程过程调用)框架实际是提供了一套机制，使得应用程序之间可以进行通信，而且也遵从server/client模型。使用的时候客户端调用server端提供的接口就像是调用本地的函数一样。如下图所示就是一个典型的RPC结构图。
客户端使用RPC调用远程方法，客户端的存根发起请求，对请求的数据使用protobuf对象序列化和压缩。 服务器接收到请求后，解码请求数据，使用protobuf反序列化为内存对象，处理业务逻辑并返回响应结果。 客户端收到服务端响应，解码响应数据，唤醒阻塞客户端。 grpc特性 基于HTTP/2 HTTP/2 提供了连接多路复用、双向流、服务器推送、请求优先级、首部压缩等机制。可以节省带宽、降低TCP链接次数、节省CPU，帮助移动设备延长电池寿命等。gRPC 的协议设计上使用了HTTP2 现有的语义，请求和响应的数据使用HTTP Body 发送，其他的控制信息则用Header 表示。
IDL使用ProtoBuf gRPC使用ProtoBuf来定义服务，ProtoBuf是由Google开发的一种数据序列化协议（类似于XML、JSON、hessian）。ProtoBuf能够将数据进行序列化，并广泛应用在数据存储、通信协议等方面。压缩和传输效率高，语法简单，表达力强。
多语言支持（C, C++, Python, PHP, Nodejs, C#, Objective-C、Golang、Java） gRPC支持多种语言，并能够基于语言自动生成客户端和服务端功能库。目前已提供了C版本grpc、Java版本grpc-java 和 Go版本grpc-go，其它语言的版本正在积极开发中，其中，grpc支持C、C++、Node.js、Python、Ruby、Objective-C、PHP和C#等语言，grpc-java已经支持Android开发。
grpc 应用场景 gRPC已经应用在Google的云服务和对外提供的API中，其主要应用场景如下：
低延迟、高扩展性、分布式的系统 同云服务器进行通信的移动应用客户端 设计语言独立、高效、精确的新协议 便于各方面扩展的分层设计，如认证、负载均衡、日志记录、监控等 grpc 缺陷 GRPC尚未提供连接池，需要自行实现 尚未提供“服务发现”、“负载均衡”机制 因为基于HTTP2，绝大部多数HTTP Server、Nginx都尚不支持，即Nginx不能将GRPC请求作为HTTP请求来负载均衡，而是作为普通的TCP请求。（nginx1.9版本已支持） Protobuf二进制可读性差（貌似提供了Text_Fromat功能） 基于go语言 grpc 使用 工欲善其事必先利其器,开发一个grpc示例之前先安装好需要的工具和插件
下载protoc工具 https://github.com/protocolbuffers/protobuf/releases/ 注意系统和版本, 下载完成后，执行路径添加到环境变量
插件安装 go get -u github.com/golang/protobuf/protoc-gen-go， GOBIN($GOPATH/bin)添加到环境变量即可1
grpc 示例 创建proto文件 syntax = "proto3"; package pb; option go_package = "./;pb"; message Message { string body = 1; } message ReqMsgNum{ } message RespMsgNum{ int32 num = 1; } message ReqMatchWord{ string word = 1; } message RespMatchWord{ bool isMatch = 1; } service ChatService { rpc SayHello(Message) returns (Message) {} rpc GetMsgNum(ReqMsgNum) returns (stream RespMsgNum){} rpc MatchWord(stream ReqMatchWord) returns (RespMatchWord){} rpc Chat(stream Message) returns (stream Message){} } 这里定义了四个方法 sayHello 普通的rpc调用 GetMsgNum 服务端流式调用，客户端普通的rpc调用 MatchWord 客户端流式调用，服务端普通rcp调用 Chat 双向流式调用
生成对应的go文件 protoc --go_out=plugins=grpc:. chat.proto 服务端代码 package main import ( "google.golang.org/grpc" "log" "mytest/grpc/pb" "mytest/grpc/server/chat" "net" ) func main() { listen, err := net.Listen("tcp", ":1234") if err != nil { log.Fatal(err) } s := chat.ChatServer{} rpcServer := grpc.NewServer() pb.RegisterChatServiceServer(rpcServer, &amp;s) log.Println("start server") if err := rpcServer.Serve(listen); err != nil{ log.Fatal(err) } } package chat import ( "context" "log" "mytest/grpc/pb" "strings" "time" ) type ChatServer struct { } // 普通请求 func (s *ChatServer) SayHello(ctx context.Context, in *pb.Message) (*pb.Message, error) { log.Println("Receive message => ", in.Body) return &amp;pb.Message{Body: "Hello From the Server!"}, nil } // 服务端流推送消息数量 func (s *ChatServer) GetMsgTotal(in *pb.ReqMsgNum, stream pb.ChatService_GetMsgNumServer) error { var msgAmount int32 = 0 for { msgAmount++ err := stream.Send(&amp;pb.RespMsgNum{Num: msgAmount}) if err != nil { log.Println(err) break } time.Sleep(time.Second) } return nil } // 服务端接收客户端流 func (s *ChatServer) MatchWord(stream pb.ChatService_MatchWordServer) error { var matchAmount int32 for { resp, err := stream.Recv() if err != nil { log.Println(err) break } log.Println("recv word => ", resp.Word) // TODO 业务处理 是否匹配单词 if strings.Contains(resp.Word, "good") { matchAmount++ } } err := stream.SendAndClose(&amp;pb.RespMatchWord{IsMatch: matchAmount>0}) if err != nil{ log.Println(err) return err } return nil } // 双向流通信 func (s *ChatServer) Chat(stream pb.ChatService_ChatServer) error { var msg string for { resp, err := stream.Recv() if err != nil{ log.Println(err) break } log.Println("recv msg => ", resp.Body) msg = "server " + resp.Body err = stream.Send(&amp;pb.Message{Body: msg}) if err != nil{ log.Println(err) break } log.Println("send msg => ", msg) } return nil } 客户端代码 package main import ( "context" "fmt" "google.golang.org/grpc" "log" "mytest/grpc/pb" "time" ) var ctx = context.Background() func main() { conn, err := grpc.Dial(":1234", grpc.WithInsecure()) if err != nil{ log.Fatal(err) } defer conn.Close() log.Println("start client") cli := pb.NewChatServiceClient(conn) sayHello(cli) //getMsgTotal(cli) //sendWord(cli) //chat(cli) } func sayHello(cli pb.ChatServiceClient) { resp, err := cli.SayHello(ctx, &amp;pb.Message{Body: "i am tom"}) if err != nil{ log.Fatal(err) } log.Println(resp.Body) } // 服务端流的方式推送消息 func getMsgNum(cli pb.ChatServiceClient) { stream, err := cli.GetMsgNum(ctx, &amp;pb.ReqMsgNum{}) if err != nil{ log.Fatal(err) } for { resp, err := stream.Recv() if err != nil{ log.Println(err) break } log.Println("msg total => ", resp.Num) } } // 客户端流的方式发送消息 func sendWord(cli pb.ChatServiceClient){ stream, err := cli.MatchWord(ctx) if err != nil{ log.Fatal(err) } var sendStr string = "abc" for i := 0; i &lt; 5; i++{ log.Println("send str => ", sendStr) err := stream.Send(&amp;pb.ReqMatchWord{Word: sendStr}) if err != nil{ log.Fatal(err) return } sendStr += "good" time.Sleep(time.Second) } resp, err := stream.CloseAndRecv() if err != nil{ log.Println(err) return } log.Println("the word match => ", resp.IsMatch) } // 双向流收发消息 func chat(cli pb.ChatServiceClient) { stream, err := cli.Chat(ctx) if err != nil{ log.Fatal(err) } var i int var msg string for i &lt; 100 { msg = fmt.Sprintf("chat msg %d", i) fmt.Println("send msg => ", msg) err := stream.Send(&amp;pb.Message{Body: msg}) if err != nil{ fmt.Println(err) break } resp, err := stream.Recv() if err != nil{ fmt.Println(err) break } log.Println("recv msg => ", resp.Body) time.Sleep(time.Second * 2) i++ } } 遇到问题： 1. 使用protoc生成go文件提示 protoc-gen-go: unable to determine Go import path， 该问题出现原因是没有正确设置option go_package。在proto文件中添加option go_package = &ldquo;./;pb&rdquo;;其中pb是包名，可以自定义， ./表示当前目录。该选项主要是用于配置包依赖路径，例如a.proto imports b.proto,则生成的pb.go文件也有依赖关系，因此要设置该路径。
2. 运行时提示 undefined: grpc.SupportPackageIsVersion7 undefined: grpc.ClientConnInterface undefined: grpc.ClientConnInterface undefined: grpc.ServiceRegistrar 出现这个是因为 grpc和proto-gen-go 的版本问题导致的，两种解决方案。
升级grpc版本1.27或以上，笔者这里升级到1.29.1 replace google.golang.org/grpc => google.golang.org/grpc v1.29.1 降级protoc-gen-go的版本 go get -u github.com/golang/protobuf/protoc-gen-go是安装最新版的protoc-gen-go 降低protoc-gen-go的具体办法，在终端运行如下命令，这里降低到版本 v1.2.0 GIT_TAG="v1.2.0" go get -d -u github.com/golang/protobuf/protoc-gen-go git -C "$(go env GOPATH)"/src/github.com/golang/protobuf checkout $GIT_TAG go install github.com/golang/protobuf/protoc-gen-go 3. proto 请求参数或者响应参数为空 通过引入 empty.proto,具体看示例
syntax = "proto3"; import "google/protobuf/empty.proto"; package proto; message ReqHello { string message = 1; } message RespHello { string message = 1; } service Greeter { // 没有返回值 情况 rpc Hello1(ReqHello) returns (google.protobuf.Empty) {} // 没有参数 情况 rpc Hello2 (google.protobuf.Empty) returns (RespHello) {} // 没有参数，没有返回值 情况 rpc Hello3 (google.protobuf.Empty) returns (google.protobuf.Empty) {} }</content></entry><entry><title>关于我</title><url>/about.html</url><categories/><tags/><content type="html"> Hugo是用Go编写的一个开放源代码静态站点生成器，可在Apache许可证2.0 下使用。 Hugo支持TOML, YAML和JSON数据文件类型，Markdown和HTML内容文件，并使用短代码添加丰富的内容。其他值得注意的功能包括分类法、多语言模式、图像处理、自定义输出格式、HTML/CSS/JS缩小和对Sass SCSS工作流的支持。
Hugo使用了多种开源项目，包括:
https://github.com/yuin/goldmark https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper Hugo是博客、企业网站、创意作品集、在线杂志、单页应用程序甚至是数千页的网站的理想选择。
Hugo适合那些想要手工编写自己的网站代码，而不用担心设置复杂的运行时、依赖关系和数据库的人。
使用Hugo建立的网站非常快速、安全，可以部署在任何地方，包括AWS、GitHub Pages、Heroku、Netlify和任何其他托管提供商。
更多信息请访问GitHub .</content></entry><entry><title>GormV2-Mock单元测试</title><url>/post/golang/gorm-mock/</url><categories><category>golang</category></categories><tags><tag>golang</tag></tags><content type="html"> gorm v2 mock测试 平时开发中会经常用到各种数据库，做单元测试时又不想真正的连接数据库。今天介绍如何在基于gorm v2做单元测试
go-sqlmock 今天得主角就是go-sqlmock的工具，它是一个实现sql/drive mock库，不需要建立真正的数据库连接就可以在测试中模拟任何 sql 驱动程序的行为。可以很方便的在编写单元测试的时候mock sql语句的执行结果。
安装 go get github.com/DATA-DOG/go-sqlmock 示例 新建一个simple_sqlmock.go文件，添加变量DB 和 初始化DB的方法
package simple import ( "gorm.io/driver/mysql" "gorm.io/gorm" "gorm.io/gorm/logger" "log" ) var DB *gorm.DB func Init() { var err error DB, err = gorm.Open(mysql.Open("dsn"), &amp;gorm.Config{ Logger: logger.Default.LogMode(logger.Info), // 日志配置 }) if err != nil { panic(err) } } 写一个简单用户SysUser
package simple type SysUser struct { Id uint64 `gorm:"primarykey"` UserName string `gorm:"column:username;type:varchar(255);default:'';not null;comment:账号;index:idx_name"` Password string `gorm:"column:password;type:varchar(1024);default:'';not null;comment:密码"` Age int `gorm:"column:age;type:int(10);defalut:0;not null;comment:年龄"` } func (SysUser) TableName() string { return "sys_users" } 添加对用户增删改查的方法
package simple func AddUser(u *SysUser) error { if u == nil { return nil } err := DB.Model(&amp;SysUser{}).Create(u).Error if err != nil { return err } return nil } func UpdateUser(name string, age int) error { err := DB.Model(&amp;SysUser{}).Where("username=?", name).UpdateColumn("age", age).Error if err != nil { return err } return nil } func QueryUser(id uint64) (*SysUser, error) { if id == 0 { return nil, nil } var user SysUser err := DB.Model(&amp;SysUser{}).Where("id = ?", id).Scan(&amp;user).Error if err != nil { return nil, err } return &amp;user, nil } func DelUser(id uint64) error { if id == 0 { return nil } err := DB.Model(&amp;SysUser{}).Delete(&amp;SysUser{}, id).Error if err != nil { return err } return nil } 再新建一个simple_sqlmock_test 文件对用户增删改查的方法做单元测试，发现对每一个测试方法都要初始化一遍mock DB连接，做起来比较繁琐。 这里有个小技巧, 可以把初始化的工作放到TestMain中，go的测试支持会优先执行这个方法
package simple import ( "database/sql" "github.com/DATA-DOG/go-sqlmock" "github.com/smartystreets/goconvey/convey" "gorm.io/driver/mysql" "gorm.io/gorm" "reflect" "testing" ) var ( err error mysqlMock sqlmock.Sqlmock sqldb *sql.DB ) func TestMain(m *testing.M) { sqldb, mysqlMock, err = sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual)) if err != nil { panic(err) } DB, err = gorm.Open(mysql.New(mysql.Config{ Conn: sqldb, SkipInitializeWithVersion: true, }), &amp;gorm.Config{}) m.Run() } 初始化做的主要工作: 创建一个 sqlmock 的数据库连接 db 和 mock对象，mock对象管理 db 预期要执行的SQL。 让sqlmock 使用 QueryMatcherEqual 匹配器，该匹配器把mock.ExpectQuery 和 mock.ExpectExec 的参数作为预期要执行的SQL语句跟实际要执行的SQL进行相等比较。还有其他的匹配器，比如正则匹配QueryMatcherRegexp m.Run 是调用包下面各个Test函数的入口。 使用上次讲的gotests 自动生成单元测试的方法，测试代码如下:
func TestAddUser(t *testing.T) { type args struct { u *SysUser } tests := []struct { name string args args wantErr bool }{ // TODO: Add test cases. { name: "add user case1", args: args{u: &amp;SysUser{ UserName: "admin1", Password: "123456", Age: 10, }}, wantErr: false, }, { name: "add user case2", args: args{u: &amp;SysUser{ UserName: "admin2", Password: "123456", Age: 20, }}, wantErr: false, }, } mysqlMock.ExpectBegin() mysqlMock.ExpectExec("INSERT INTO `sys_users` (`username`,`password`,`age`) VALUES (?,?,?)"). WithArgs("admin1", "123456", 10). WillReturnResult(sqlmock.NewResult(1, 1)) mysqlMock.ExpectCommit() mysqlMock.ExpectBegin() mysqlMock.ExpectExec("INSERT INTO `sys_users` (`username`,`password`,`age`) VALUES (?,?,?)"). WithArgs("admin2", "123456", 20). WillReturnResult(sqlmock.NewResult(2, 1)) mysqlMock.ExpectCommit() convey.Convey("Test Add User Case", t, func() { for _, tt := range tests { convey.Convey(tt.name, func() { if err := AddUser(tt.args.u); (err != nil) != tt.wantErr { t.Errorf("AddUser() error = %v, wantErr %v", err, tt.wantErr) } }) } }) } func TestUpdateUser(t *testing.T) { type args struct { Name string Age int } tests := []struct { name string args args wantErr bool }{ // TODO: Add test cases. { name: "update user case1", args: args{ Name: "james", Age: 10, }, wantErr: false, }, { name: "update user case2", args: args{ Name: "jordan", Age: 23, }, wantErr: false, }, } mysqlMock.ExpectBegin() mysqlMock.ExpectExec("UPDATE `sys_users` SET `age`=? WHERE username=?"). WithArgs(10, "james"). WillReturnResult(sqlmock.NewResult(1, 1)) mysqlMock.ExpectCommit() mysqlMock.ExpectBegin() mysqlMock.ExpectExec("UPDATE `sys_users` SET `age`=? WHERE username=?"). WithArgs(23, "jordan"). WillReturnResult(sqlmock.NewResult(1, 1)) mysqlMock.ExpectCommit() convey.Convey("Test Update User Case", t, func() { for _, tt := range tests { convey.Convey(tt.name, func() { if err := UpdateUser(tt.args.Name, tt.args.Age); (err != nil) != tt.wantErr { t.Errorf("UpdateUser() error = %v, wantErr %v", err, tt.wantErr) } }) } }) } func TestQueryUser(t *testing.T) { type args struct { id uint64 } tests := []struct { name string args args want *SysUser wantErr bool }{ // TODO: Add test cases. { name: "query user case1", args: args{id: 1}, want: &amp;SysUser{ Id: 1, UserName: "james", Password: "123456", Age: 10, }, wantErr: false, }, { name: "query user case2", args: args{id: 2}, want: &amp;SysUser{ Id: 2, UserName: "jordan", Password: "123456", Age: 23, }, wantErr: false, }, } mysqlMock.ExpectQuery("SELECT * FROM `sys_users` WHERE id = ?"). WithArgs(1). WillReturnRows(sqlmock.NewRows([]string{"id", "username", "password", "age"}).AddRow(1, "james", "123456", 10)) mysqlMock.ExpectQuery("SELECT * FROM `sys_users` WHERE id = ?"). WithArgs(2). WillReturnRows(sqlmock.NewRows([]string{"id", "username", "password", "age"}).AddRow(2, "jordan", "123456", 23)) convey.Convey("Test Query User Case", t, func() { for _, tt := range tests { convey.Convey(tt.name, func() { got, err := QueryUser(tt.args.id) if (err != nil) != tt.wantErr { t.Errorf("QueryUser() error = %v, wantErr %v", err, tt.wantErr) return } if !reflect.DeepEqual(got, tt.want) { t.Errorf("QueryUser() = %v, want %v", got, tt.want) } }) } }) } func TestDelUser(t *testing.T) { type args struct { id uint64 } tests := []struct { name string args args wantErr bool }{ // TODO: Add test cases. { name: "del user case1", args: args{id: 1}, wantErr: false, }, { name: "del user case2", args: args{id: 2}, wantErr: false, }, } mysqlMock.ExpectBegin() mysqlMock.ExpectExec("DELETE FROM `sys_users` WHERE `sys_users`.`id` = ?").WithArgs(1).WillReturnResult(sqlmock.NewResult(1, 1)) mysqlMock.ExpectCommit() mysqlMock.ExpectBegin() mysqlMock.ExpectExec("DELETE FROM `sys_users` WHERE `sys_users`.`id` = ?").WithArgs(2).WillReturnResult(sqlmock.NewResult(1, 1)) mysqlMock.ExpectCommit() convey.Convey("Test Del User Case", t, func() { for _, tt := range tests { convey.Convey(tt.name, func() { if err := DelUser(tt.args.id); (err != nil) != tt.wantErr { t.Errorf("DelUser() error = %v, wantErr %v", err, tt.wantErr) } }) } }) } 执行go test
go test -v simple_sqlmock.go simple_sqlmock_test.go === RUN TestAddUser Test Add User Case add user case1 add user case2 0 total assertions --- PASS: TestAddUser (0.00s) === RUN TestUpdateUser Test Update User Case update user case1 update user case2 0 total assertions --- PASS: TestUpdateUser (0.00s) === RUN TestQueryUser Test Query User Case query user case1 query user case2 0 total assertions --- PASS: TestQueryUser (0.00s) === RUN TestDelUser Test Del User Case del user case1 del user case2 0 total assertions --- PASS: TestDelUser (0.00s) PASS ok command-line-arguments 0.015s 能看到测试结果都通过了，也可以做一些反向测试，故意改错一些参数，提示sql 语句不匹配等错误导致测试fail
总结 学习并使用了go-sqlmock工具对使用gorm框架的逻辑进行单元测试，希望大家有所收获</content></entry><entry><title>Etcd在go中的使用</title><url>/post/golang/etcd/</url><categories><category>golang</category></categories><tags><tag>golang</tag></tags><content type="html"> Etcd 介绍 etcd 是一个高可用的分布式键值(key-value)存储数据库。具有以下特点:
简单：安装配置简单，而且提供了 HTTP API 进行交互，使用也很简单 键值对存储：将数据存储在分层组织的目录中，如同在标准文件系统中 监测变更：监测特定的键或目录以进行更改，并对值的更改做出反应 安全：支持 SSL 证书验证 快速：根据官方提供的 benchmark 数据，单实例支持每秒 2k+ 读操作 可靠：采用 raft 算法，实现分布式系统数据的可用性和一致性 使用场景 服务注册和发现 键值对存储 消息的发布和订阅 分布式通知与协调 分布式锁 技术选型 名称 优点 缺点 接口 一致性算法 zookeeper 1.功能强大，不仅仅只是服务发现 2.提供watcher机制能实时获取服务提供者的状态 3.dubbo等框架支持 1.没有健康检查2.需在服务中集成sdk，复杂度高3.不支持多数据中心 sdk Paxos consul 1.简单易用，不需要集成sdk2.自带健康检查3.支持多数据中心4.提供web管理界面 1.不能实时获取服务信息的变化通知 http/dns Raft etcd 1.简单易用，不需要集成sdk2.可配置性强 1.没有健康检查2.需配合第三方工具一起完成服务发现3.不支持多数据中心 http Raft etcd 安装 源码安装 使用源码安装需要先安装go语言环境 git clone https://github.com/etcd-io/etcd.git cd etcd ./build 执行如下测试命令，确保安装成功
$ ./etcdctl version etcdctl version: 3.4.4 API version: 3.4 docker 安装 单节点安装 version: '3' networks: myetcd_single: services: etcd: image: quay.io/coreos/etcd container_name: etcd_single command: etcd -name etcd1 -advertise-client-urls http://0.0.0.0:2379 -listen-client-urls http://0.0.0.0:2379 -listen-peer-urls http://0.0.0.0:2380 ports: - 12379:2379 - 12380:2380 volumes: - ./data:/etcd-data networks: - myetcd_single etcdkeeper: image: deltaprojects/etcdkeeper container_name: etcdkeeper_single ports: - 8088:8080 networks: - myetcd_single 集群安装
version: '3' networks: myetcd: services: etcd1: image: quay.io/coreos/etcd:v3.5.1 container_name: etcd1 command: etcd -name etcd1 -advertise-client-urls http://0.0.0.0:2379 -listen-client-urls http://0.0.0.0:2379 -listen-peer-urls http://0.0.0.0:2380 -initial-cluster-token etcd-cluster -initial-cluster "etcd1=http://etcd1:2380,etcd2=http://etcd2:2380,etcd3=http://etcd3:2380" -initial-cluster-state new ports: - 12379:2379 - 12380:2380 volumes: - ./data/etcd1:/etcd-data networks: - myetcd etcd2: image: quay.io/coreos/etcd:v3.5.1 container_name: etcd2 command: etcd -name etcd2 -advertise-client-urls http://0.0.0.0:2379 -listen-client-urls http://0.0.0.0:2379 -listen-peer-urls http://0.0.0.0:2380 -initial-cluster-token etcd-cluster -initial-cluster "etcd1=http://etcd1:2380,etcd2=http://etcd2:2380,etcd3=http://etcd3:2380" -initial-cluster-state new ports: - 22379:2379 - 22380:2380 volumes: - ./data/etcd2:/etcd-data networks: - myetcd etcd3: image: quay.io/coreos/etcd:v3.5.1 container_name: etcd3 command: etcd -name etcd3 -advertise-client-urls http://0.0.0.0:2379 -listen-client-urls http://0.0.0.0:2379 -listen-peer-urls http://0.0.0.0:2380 -initial-cluster-token etcd-cluster -initial-cluster "etcd1=http://etcd1:2380,etcd2=http://etcd2:2380,etcd3=http://etcd3:2380" -initial-cluster-state new ports: - 32379:2379 - 32380:2380 volumes: - ./data/etcd3:/etcd-data networks: - myetcd etcdkeeper: image: deltaprojects/etcdkeeper container_name: etcdkeeper ports: - 8088:8080 networks: - myetcd 执行 docker-compose up -d 命令自动安装 etcd 使用示例 package main import ( "context" "fmt" "time" "go.etcd.io/etcd/clientv3" ) func main() { // 初始化etcd客户端 cli, err := clientv3.New(clientv3.Config{ Endpoints: []string{"localhost:12379"}, DialTimeout: 5 * time.Second, }) if err != nil { fmt.Println("connect failed, err:", err) return } Put(cli, "/node/node1", "server info node1") Put(cli, "/node/node2", "server info node2") Put(cli, "/node/node3", "server info node3") Get(cli, "/node/node1") } // 存储一个key value func Put(c *clientv3.Client, key string, value string) { ctx, cancel := context.WithTimeout(context.Background(), time.Second) defer cancel() putResp, err := c.Put(ctx, key, value) if err != nil { fmt.Println("etcd put err => ", err) return } fmt.Printf("put key:%s value:%s", putResp.PrevKv.Key, putResp.PrevKv.Value) } // 获取key相关的value func Get(c *clientv3.Client, key string) { ctx, cancel := context.WithTimeout(context.Background(), time.Second) defer cancel() getResp, err := c.Get(ctx, key) if err != nil { fmt.Println("etcd get err => ", err) return } for _, v := range getResp.Kvs { fmt.Printf("k %s v %s\n", v.Key, v.Value) } } // 删除key func Del(c *clientv3.Client, key string) { ctx, cancel := context.WithTimeout(context.Background(), time.Second) defer cancel() delResp, err := c.Delete(ctx, key) if err != nil { fmt.Println("etcd del err => ", err) return } fmt.Println("del result => ", delResp.Deleted) } // 监听key的删除更新事件 func Watch(c *clientv3.Client, key string) { watchCh := c.Watch(context.Background(), key) for resp := range watchCh { for _, ev := range resp.Events { fmt.Printf("event => %s, key => %s, value => %s", ev.Type, ev.Kv.Key, ev.Kv.Value) } } }</content></entry><entry><title>gotests单元测试</title><url>/post/golang/gotests/</url><categories><category>golang</category></categories><tags><tag>golang</tag></tags><content type="html"> Go单元测试 go 程序中一般使用官方的go test 做测试，面对一些复杂情况和紧急需求写单元测试就变得有些仓促，今天介绍一款利器gotests来写单元测试
安装 go get -u github.com/cweill/gotests/... 以一个不同类型比较相等的列子做个测试，下面是一个simple.go文件
package simple import "reflect" type Point struct { X int Y int } type Circular struct { Point Peri float32 } type PointCollect struct { Points []Point } // 数组相等 func TArrayEqual(a, b [10]int) bool { if a == b { return true } return false } // 切片相等 func TSliceEqual(a, b []int) bool { if reflect.DeepEqual(a, b) { return true } return false } // 字典相等 func TMapEqual(a, b map[string]string) bool { if reflect.DeepEqual(a, b) { return true } return false } // 结构体相等 func TPointEqual(a, b Point) bool { if a == b { return true } return false } // 结构体相等 func TCircularEqual(a, b Circular) bool { if a == b { return true } return false } // 切片结构体相等 func TPointCollect(a, b PointCollect) bool { if reflect.DeepEqual(a, b) { return true } return false } 执行 gotests -all -w simple.go 执行这个命令会自动生成simple_test.go文件 -all命令为所有的函数生成测试函数
func TestTArrayEqual(t *testing.T) { type args struct { a [10]int b [10]int } tests := []struct { name string args args want bool }{ // TODO: Add test cases. } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { if got := TArrayEqual(tt.args.a, tt.args.b); got != tt.want { t.Errorf("TArrayEqual() = %v, want %v", got, tt.want) } }) } } ... 只需要填写对应的test cases 就可以了
package simple import "testing" func TestTArrayEqual(t *testing.T) { type args struct { a [10]int b [10]int } tests := []struct { name string args args want bool }{ // TODO: Add test cases. { name: "good case", args: args{ a: [10]int{1, 2, 3, 4}, b: [10]int{1, 2, 3, 4}, }, want: true, }, { name: "bad case", args: args{ a: [10]int{1, 2, 3}, b: [10]int{1, 2, 3, 4}, }, want: false, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { if got := TArrayEqual(tt.args.a, tt.args.b); got != tt.want { t.Errorf("TArrayEqual() = %v, want %v", got, tt.want) } }) } } func TestTSliceEqual(t *testing.T) { type args struct { a []int b []int } tests := []struct { name string args args want bool }{ // TODO: Add test cases. { name: "good case", args: args{ a: []int{1, 2, 3}, b: []int{1, 2, 3}, }, want: true, }, { name: "bad case", args: args{ a: []int{1, 2, 3, 4}, b: []int{1, 2, 3}, }, want: false, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { if got := TSliceEqual(tt.args.a, tt.args.b); got != tt.want { t.Errorf("TSliceEqual() = %v, want %v", got, tt.want) } }) } } func TestTMapEqual(t *testing.T) { type args struct { a map[string]string b map[string]string } tests := []struct { name string args args want bool }{ // TODO: Add test cases. { name: "good case", args: args{ a: map[string]string{"a":"1", "b":"2", "c":"3"}, b: map[string]string{"a":"1", "b":"2", "c":"3"}, }, want: true, }, { name: "bad case", args: args{ a: map[string]string{"a":"1", "b":"2", "c":"3"}, b: map[string]string{"d":"4", "e":"5", "f":"6"}, }, want: false, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { if got := TMapEqual(tt.args.a, tt.args.b); got != tt.want { t.Errorf("TMapEqual() = %v, want %v", got, tt.want) } }) } } func TestTPointEqual(t *testing.T) { type args struct { a Point b Point } tests := []struct { name string args args want bool }{ // TODO: Add test cases. { name: "good case", args: args{ a: Point{X: 1, Y: 2}, b: Point{X: 1, Y: 2}, }, want: true, }, { name: "bad case", args: args{ a: Point{X: 1, Y: 1}, b: Point{X: 1, Y: 2}, }, want: false, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { if got := TPointEqual(tt.args.a, tt.args.b); got != tt.want { t.Errorf("TPointEqual() = %v, want %v", got, tt.want) } }) } } func TestTCircularEqual(t *testing.T) { type args struct { a Circular b Circular } tests := []struct { name string args args want bool }{ // TODO: Add test cases. { name: "good case", args: args{ a: Circular{ Point: Point{X: 1, Y: 1}, Peri: 1.5, }, b: Circular{ Point: Point{X: 1, Y: 1}, Peri: 1.5, }, }, want: true, }, { name: "good case", args: args{ a: Circular{ Point: Point{X: 1, Y: 1}, Peri: 1.5, }, b: Circular{ Point: Point{X: 1, Y: 1}, Peri: 2.5, }, }, want: false, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { if got := TCircularEqual(tt.args.a, tt.args.b); got != tt.want { t.Errorf("TCircularEqual() = %v, want %v", got, tt.want) } }) } } func TestTPointCollect(t *testing.T) { type args struct { a PointCollect b PointCollect } tests := []struct { name string args args want bool }{ // TODO: Add test cases. { name: "good case", args: args{ a: PointCollect{[]Point{{ X: 1, Y: 1, }, { X: 1, Y: 2, }}}, b: PointCollect{[]Point{{ X: 1, Y: 1, }, { X: 1, Y: 2, }}}, }, want: true, }, { name: "bad case", args: args{ a: PointCollect{[]Point{{ X: 1, Y: 1, }, { X: 1, Y: 2, }}}, b: PointCollect{[]Point{{ X: 2, Y: 2, }, { X: 2, Y: 4, }}}, }, want: false, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { if got := TPointCollect(tt.args.a, tt.args.b); got != tt.want { t.Errorf("TPointCollect() = %v, want %v", got, tt.want) } }) } } 测试 go test -v === RUN TestTArrayEqual === RUN TestTArrayEqual/good_case === RUN TestTArrayEqual/bad_case --- PASS: TestTArrayEqual (0.00s) --- PASS: TestTArrayEqual/good_case (0.00s) --- PASS: TestTArrayEqual/bad_case (0.00s) === RUN TestTSliceEqual === RUN TestTSliceEqual/good_case === RUN TestTSliceEqual/bad_case --- PASS: TestTSliceEqual (0.00s) --- PASS: TestTSliceEqual/good_case (0.00s) --- PASS: TestTSliceEqual/bad_case (0.00s) === RUN TestTMapEqual === RUN TestTMapEqual/good_case === RUN TestTMapEqual/bad_case --- PASS: TestTMapEqual (0.00s) --- PASS: TestTMapEqual/good_case (0.00s) --- PASS: TestTMapEqual/bad_case (0.00s) === RUN TestTPointEqual === RUN TestTPointEqual/good_case === RUN TestTPointEqual/bad_case --- PASS: TestTPointEqual (0.00s) --- PASS: TestTPointEqual/good_case (0.00s) --- PASS: TestTPointEqual/bad_case (0.00s) === RUN TestTCircularEqual === RUN TestTCircularEqual/good_case === RUN TestTCircularEqual/good_case#01 --- PASS: TestTCircularEqual (0.00s) --- PASS: TestTCircularEqual/good_case (0.00s) --- PASS: TestTCircularEqual/good_case#01 (0.00s) === RUN TestTPointCollect === RUN TestTPointCollect/good_case === RUN TestTPointCollect/bad_case --- PASS: TestTPointCollect (0.00s) --- PASS: TestTPointCollect/good_case (0.00s) --- PASS: TestTPointCollect/bad_case (0.00s) PASS 看到写的测试已经全部通过了
总结 写单元测试是很多程序员不喜欢面对了，今天介绍的gotests自动生成测试文件的工具，减少了写测试文件的负担，能够大大提高程序的健壮性和稳定性 。</content></entry><entry><title>GMP调度器简介</title><url>/post/golang/gmp/</url><categories><category>golang</category></categories><tags><tag>golang</tag></tags><content type="html"> GO 语言的调度器 目录 GMP 模型简介 调度器实现机制 GMP 模型简介 先来一张经典的GMP 关系图 G 是go程序中调度器中的一个任务，类似操作系统中的线程，主要处理任务。 M 是内核线程的一种抽象，由操作系统负责调度和管理，主要负责执行goroutine。 P 是go程序运行期的本地调度器，提供线程的上下文环境，主要负责goroutine和线程的中介工作。 调度器的实现机制 package main func main(){ ch := make(chan int) go func(){ ch &lt;- 1 } &lt;-ch } 只要在方法前面加上关键字go就能很容易的开启一个goroutine, 如上 述代码所示， 是不是so easy。可他究竟是怎么调度的呢？先来看下Go 程序运行的结构，Go 程序主要两部分构成 用户层和运行层，见下图
在Runitme 层有三个基础的结构体runtime.G, runtime.M, runtime.P, 在加上一个核心的结构体runtime.Sche 来实现goroutine的调度保证Go 程序的高效执行，下面介绍它是如何高效的调度的。
Go 的调度器是有两个goroutine队列 的，一个是放在P 上的Local 队列，一个是放在sche上的全局队列。早期的版本确实只有一个全局队列，但当并发比较大的时后多个M获取G时导致加锁解锁的开销比较大，后来的版本就引入了P, 在P上有一个Local队列从而减少锁的开销。当开启一个goroutine时，先把G放到P上的队列当中，等需要执行G时，P需要绑定一个M，将G运行在M上。未分配给P的Goroutine则放到全局队列当中。
每个goroutine执行的快慢不一样，会产生有的P很忙，有的P很闲。 调度器让空闲的P偷其他P上goroutine到自己的队列上，其他p上也没有则从全局队列中偷取，从而充分利用了计算机上的每一个cup高效的执行任务。（P:想偷懒都不行了 哈哈）
当一个goroutine执行一些系统任务阻塞了M挂起来怎么办呢？下面从同步和异步分析下
先分析下同步的情况，当G1 进行系统调用时，M1就被阻塞了，G1挂在M1上, M2被引入了到P上，G2继续被调度。当G1的系统调用完成以后G1又会被放入P的LRQ当中，等待被调度执行。 再来看下异步的情况，当G1进行网络读写时，G1的异步请求会被netpoll接手，这时候M是没有被阻塞的，G2会被继续执行。等G1的异步请求完成以后G1 又会重新放到P的LRQ当中，等待被调度执行。 总结 介绍了GMP模型，主要介绍了每个模型是什么和它的主要作用 为了能够更好的并发执行，探究了调度器的实现机制。这里也只是抛砖引玉，调度机制其实很复杂，goroutine的各种状态，协作式和抢占式的调度实现等，后面从源码的角度再分析它的复杂机制。</content></entry><entry><title>Go Channel 底层实现</title><url>/post/golang/go-channel/</url><categories><category>golang</category></categories><tags><tag>golang</tag></tags><content type="html"> Go Channel 底层实现 目录 channel 是什么 channel 的创建 channel 的发送 channel 的接收 channel 的关闭 channel 是什么 “Do not communicate by sharing memory; instead, share memory by communicating.”
不要通过共享内存通信，通过通信来共享内存。很经典的go的并发哲学，依赖csp模型， 通过channel实现。
go的并发主要靠goroutine实现的，而channel则像一个管道一样， 实现goroutine之间的通信。虽然也可以通过锁，原子操作能够实现数据的同步，但使用channel更优雅。
总结一下，channel 是并发安全的管道，主要用于goroutine之间的消息传递和事件通知。
再来看一下在go中channel的数据结构
type hchan struct { // 元素数量 qcount uint // 底层循环数组的长度 dataqsiz uint // 指向底层循环数组的指针 buf unsafe.Pointer // 元素大小 elemsize uint16 // 是否被关闭 closed uint32 // 元素类型 elemtype *_type // 已发送元素在循环数组中的索引 sendx uint // 已接收元素在循环数组中的索引 recvx uint // 等待接收的 goroutine 队列 recvq waitq // 等待发送的 goroutine 队列 sendq waitq // 锁 lock mutex } 结合下图更直观的看一下
channel 的创建 根据channel的size分为无缓冲和有缓冲channel
// 无缓冲channel ch1 := make(chan int) // 有缓冲channel ch2 := make(chan int, 2) 根据channel的发送接收能力来将它分为三种类型, 不指明方向的channel技能发送也能接收，&lt;-chan 只能发送， chan&lt;- 只能接收。
// 可以发送和接收T类型的数据 chan T // 只能发送T类型的数据 chan &lt;- T // 只能接收T类型的数据 &lt;-chan T 使用make函数就可以创建一个能够收发的channel, 只能读或者写的channel 一般作为函数参数做限制
var wg sync.WaitGroup ch1 := make(chan int) ch2 := make(chan int, 2) wg.Add(2) // 只能从recvCh接收数据 go func(recvCh &lt;-chan int) { data := &lt;-recvCh fmt.Println(data) wg.Done() }(ch1) // 只能向sendCh发送数据 go func(sendCh chan&lt;- int) { sendCh &lt;- 1 wg.Done() }(ch2) wg.Wait() make 函数最终调用了 /go/src/runtime/chan.go 下面的makechan方法，主要做了chan的初始化内存分配
func makechan(t *chantype, size int) *hchan { elem := t.elem // compiler checks this but be safe. if elem.size >= 1&lt;&lt;16 { throw("makechan: invalid channel element type") } if hchanSize%maxAlign != 0 || elem.align > maxAlign { throw("makechan: bad alignment") } mem, overflow := math.MulUintptr(elem.size, uintptr(size)) if overflow || mem > maxAlloc-hchanSize || size &lt; 0 { panic(plainError("makechan: size out of range")) } // Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers. // buf points into the same allocation, elemtype is persistent. // SudoG's are referenced from their owning thread so they can't be collected. // TODO(dvyukov,rlh): Rethink when collector can move allocated objects. var c *hchan switch { case mem == 0: // Queue or element size is zero. c = (*hchan)(mallocgc(hchanSize, nil, true)) // Race detector uses this location for synchronization. c.buf = c.raceaddr() case elem.ptrdata == 0: // Elements do not contain pointers. // Allocate hchan and buf in one call. c = (*hchan)(mallocgc(hchanSize+mem, nil, true)) c.buf = add(unsafe.Pointer(c), hchanSize) default: // Elements contain pointers. c = new(hchan) c.buf = mallocgc(mem, elem, true) } c.elemsize = uint16(elem.size) c.elemtype = elem c.dataqsiz = uint(size) lockInit(&amp;c.lock, lockRankHchan) if debugChan { print("makechan: chan=", c, "; elemsize=", elem.size, "; dataqsiz=", size, "\n") } return c } channel的发送 ch := make(chan int, 3) ch &lt;- 1 channel的发送的代码很简单，不过这只是编译器表面的语法糖而已， 实际上调用了runtime.chansend函数
// 位于 src/runtime/chan.go func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { // 如果 channel 是 nil if c == nil { // 不能阻塞，直接返回 false，表示未发送成功 if !block { return false } // 当前 goroutine 被挂起 gopark(nil, nil, "chan send (nil chan)", traceEvGoStop, 2) throw("unreachable") } // 省略 debug 相关…… // 对于不阻塞的 send，快速检测失败场景 // // 如果 channel 未关闭且 channel 没有多余的缓冲空间。这可能是： // 1. channel 是非缓冲型的，且等待接收队列里没有 goroutine // 2. channel 是缓冲型的，但循环数组已经装满了元素 if !block &amp;&amp; c.closed == 0 &amp;&amp; ((c.dataqsiz == 0 &amp;&amp; c.recvq.first == nil) || (c.dataqsiz > 0 &amp;&amp; c.qcount == c.dataqsiz)) { return false } var t0 int64 if blockprofilerate > 0 { t0 = cputicks() } // 锁住 channel，并发安全 lock(&amp;c.lock) // 如果 channel 关闭了 if c.closed != 0 { // 解锁 unlock(&amp;c.lock) // 直接 panic panic(plainError("send on closed channel")) } // 如果接收队列里有 goroutine，直接将要发送的数据拷贝到接收 goroutine if sg := c.recvq.dequeue(); sg != nil { send(c, sg, ep, func() { unlock(&amp;c.lock) }, 3) return true } // 对于缓冲型的 channel，如果还有缓冲空间 if c.qcount &lt; c.dataqsiz { // qp 指向 buf 的 sendx 位置 qp := chanbuf(c, c.sendx) // …… // 将数据从 ep 处拷贝到 qp typedmemmove(c.elemtype, qp, ep) // 发送游标值加 1 c.sendx++ // 如果发送游标值等于容量值，游标值归 0 if c.sendx == c.dataqsiz { c.sendx = 0 } // 缓冲区的元素数量加一 c.qcount++ // 解锁 unlock(&amp;c.lock) return true } // 如果不需要阻塞，则直接返回错误 if !block { unlock(&amp;c.lock) return false } // channel 满了，发送方会被阻塞。接下来会构造一个 sudog // 获取当前 goroutine 的指针 gp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } mysg.elem = ep mysg.waitlink = nil mysg.g = gp mysg.selectdone = nil mysg.c = c gp.waiting = mysg gp.param = nil // 当前 goroutine 进入发送等待队列 c.sendq.enqueue(mysg) // 当前 goroutine 被挂起 goparkunlock(&amp;c.lock, "chan send", traceEvGoBlockSend, 3) // 从这里开始被唤醒了（channel 有机会可以发送了） if mysg != gp.waiting { throw("G waiting list is corrupted") } gp.waiting = nil if gp.param == nil { if c.closed == 0 { throw("chansend: spurious wakeup") } // 被唤醒后，channel 关闭了。坑爹啊，panic panic(plainError("send on closed channel")) } gp.param = nil if mysg.releasetime > 0 { blockevent(mysg.releasetime-t0, 2) } // 去掉 mysg 上绑定的 channel mysg.c = nil releaseSudog(mysg) return true } 上面的代码注释很清楚说明了channel的发送流程，下面小结一下发送的过程：
向一个nil channel发送数据，会调用gopark函数将当前goroutine挂起 向一个已经关闭的channel发送数据，直接会panic 如果channel的recvq当前队列中有被阻塞的接收者，则直接将数据发送给当前goroutine, 并将它设置成下一个运行的goroutine 当channel的缓冲区还有空闲空间，则将数据发送到sendx指向缓冲区的位置 当没有缓冲区或者缓冲区满了，则会创建一个sudog的结构体将其放到channel的sendq队列当中陷入休眠等待被唤醒 channel 的接收 ch := make(chan int) // 不带ok的方式 data := &lt;- ch // 带ok的方式 data, ok := &lt;-ch channel的接收分为两种方式，也是编译器语法糖的结果，最终会调用runtime.chanrecv1 和 runtime.chanrecv2,而这两个函数最终调用了runtime.chanrecv
// entry points for &lt;- c from compiled code func chanrecv1(c *hchan, elem unsafe.Pointer) { chanrecv(c, elem, true) } func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) { _, received = chanrecv(c, elem, true) return } 接下来看一下chanrecv的代码
// 位于 src/runtime/chan.go // chanrecv 函数接收 channel c 的元素并将其写入 ep 所指向的内存地址。 // 如果 ep 是 nil，说明忽略了接收值。 // 如果 block == false，即非阻塞型接收，在没有数据可接收的情况下，返回 (false, false) // 否则，如果 c 处于关闭状态，将 ep 指向的地址清零，返回 (true, false) // 否则，用返回值填充 ep 指向的内存地址。返回 (true, true) // 如果 ep 非空，则应该指向堆或者函数调用者的栈 func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { // 省略 debug 内容 ………… // 如果是一个 nil 的 channel if c == nil { // 如果不阻塞，直接返回 (false, false) if !block { return } // 否则，接收一个 nil 的 channel，goroutine 挂起 gopark(nil, nil, "chan receive (nil chan)", traceEvGoStop, 2) // 不会执行到这里 throw("unreachable") } // 在非阻塞模式下，快速检测到失败，不用获取锁，快速返回 // 当我们观察到 channel 没准备好接收： // 1. 非缓冲型，等待发送列队 sendq 里没有 goroutine 在等待 // 2. 缓冲型，但 buf 里没有元素 // 之后，又观察到 closed == 0，即 channel 未关闭。 // 因为 channel 不可能被重复打开，所以前一个观测的时候 channel 也是未关闭的， // 因此在这种情况下可以直接宣布接收失败，返回 (false, false) if !block &amp;&amp; (c.dataqsiz == 0 &amp;&amp; c.sendq.first == nil || c.dataqsiz > 0 &amp;&amp; atomic.Loaduint(&amp;c.qcount) == 0) &amp;&amp; atomic.Load(&amp;c.closed) == 0 { return } var t0 int64 if blockprofilerate > 0 { t0 = cputicks() } // 加锁 lock(&amp;c.lock) // channel 已关闭，并且循环数组 buf 里没有元素 // 这里可以处理非缓冲型关闭 和 缓冲型关闭但 buf 无元素的情况 // 也就是说即使是关闭状态，但在缓冲型的 channel， // buf 里有元素的情况下还能接收到元素 if c.closed != 0 &amp;&amp; c.qcount == 0 { if raceenabled { raceacquire(unsafe.Pointer(c)) } // 解锁 unlock(&amp;c.lock) if ep != nil { // 从一个已关闭的 channel 执行接收操作，且未忽略返回值 // 那么接收的值将是一个该类型的零值 // typedmemclr 根据类型清理相应地址的内存 typedmemclr(c.elemtype, ep) } // 从一个已关闭的 channel 接收，selected 会返回true return true, false } // 等待发送队列里有 goroutine 存在，说明 buf 是满的 // 这有可能是： // 1. 非缓冲型的 channel // 2. 缓冲型的 channel，但 buf 满了 // 针对 1，直接进行内存拷贝（从 sender goroutine -> receiver goroutine） // 针对 2，接收到循环数组头部的元素，并将发送者的元素放到循环数组尾部 if sg := c.sendq.dequeue(); sg != nil { // Found a waiting sender. If buffer is size 0, receive value // directly from sender. Otherwise, receive from head of queue // and add sender's value to the tail of the queue (both map to // the same buffer slot because the queue is full). recv(c, sg, ep, func() { unlock(&amp;c.lock) }, 3) return true, true } // 缓冲型，buf 里有元素，可以正常接收 if c.qcount > 0 { // 直接从循环数组里找到要接收的元素 qp := chanbuf(c, c.recvx) // ………… // 代码里，没有忽略要接收的值，不是 "&lt;- ch"，而是 "val &lt;- ch"，ep 指向 val if ep != nil { typedmemmove(c.elemtype, ep, qp) } // 清理掉循环数组里相应位置的值 typedmemclr(c.elemtype, qp) // 接收游标向前移动 c.recvx++ // 接收游标归零 if c.recvx == c.dataqsiz { c.recvx = 0 } // buf 数组里的元素个数减 1 c.qcount-- // 解锁 unlock(&amp;c.lock) return true, true } if !block { // 非阻塞接收，解锁。selected 返回 false，因为没有接收到值 unlock(&amp;c.lock) return false, false } // 接下来就是要被阻塞的情况了 // 构造一个 sudog gp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // 待接收数据的地址保存下来 mysg.elem = ep mysg.waitlink = nil gp.waiting = mysg mysg.g = gp mysg.selectdone = nil mysg.c = c gp.param = nil // 进入channel 的等待接收队列 c.recvq.enqueue(mysg) // 将当前 goroutine 挂起 goparkunlock(&amp;c.lock, "chan receive", traceEvGoBlockRecv, 3) // 被唤醒了，接着从这里继续执行一些扫尾工作 if mysg != gp.waiting { throw("G waiting list is corrupted") } gp.waiting = nil if mysg.releasetime > 0 { blockevent(mysg.releasetime-t0, 2) } closed := gp.param == nil gp.param = nil mysg.c = nil releaseSudog(mysg) return true, !closed } 上面的代码注释很清楚说明了channel的接收数据的流程，下面小结一下接收数据的过程：
从一个nil channel接收数据，会调用gopark函数将当前goroutine挂起，让出处理器的使用权 从一个已经关闭并且缓冲区中没有元素的channel中接收数据，则会接收到该类型的默认元素，并且第二个返回值返回false 如果channel没有缓冲区且sendq的队列有阻塞的goroutine，则把sendq队列头的sudog中保存的元素值copy到目标地址中 如果channel有缓冲区且缓冲区里面有元素，则把recvx指向缓冲区的元素值copy到目标地址当中，sendq队列头的sudog的元素值copy到recvx指向缓冲区位置的地址当中, 这块有点不太好理解，看下图 5. 当上面的条件都不符合时，则会创建一个sudog的结构体将其放到channel的recvq队列当中陷入休眠等待被唤醒
channel的关闭 ch := make(chan int) close(ch) 关闭channel相对简单，编译器会转换成runtime.closechan函数
func closechan(c *hchan) { // 关闭一个 nil channel，panic if c == nil { panic(plainError("close of nil channel")) } // 上锁 lock(&amp;c.lock) // 如果 channel 已经关闭 if c.closed != 0 { unlock(&amp;c.lock) // panic panic(plainError("close of closed channel")) } // ………… // 修改关闭状态 c.closed = 1 var glist *g // 将 channel 所有等待接收队列的里 sudog 释放 for { // 从接收队列里出队一个 sudog sg := c.recvq.dequeue() // 出队完毕，跳出循环 if sg == nil { break } // 如果 elem 不为空，说明此 receiver 未忽略接收数据 // 给它赋一个相应类型的零值 if sg.elem != nil { typedmemclr(c.elemtype, sg.elem) sg.elem = nil } if sg.releasetime != 0 { sg.releasetime = cputicks() } // 取出 goroutine gp := sg.g gp.param = nil if raceenabled { raceacquireg(gp, unsafe.Pointer(c)) } // 相连，形成链表 gp.schedlink.set(glist) glist = gp } // 将 channel 等待发送队列里的 sudog 释放 // 如果存在，这些 goroutine 将会 panic for { // 从发送队列里出队一个 sudog sg := c.sendq.dequeue() if sg == nil { break } // 发送者会 panic sg.elem = nil if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = nil if raceenabled { raceacquireg(gp, unsafe.Pointer(c)) } // 形成链表 gp.schedlink.set(glist) glist = gp } // 解锁 unlock(&amp;c.lock) // Ready all Gs now that we've dropped the channel lock. // 遍历链表 for glist != nil { // 取最后一个 gp := glist // 向前走一步，下一个唤醒的 g glist = glist.schedlink.ptr() gp.schedlink = 0 // 唤醒相应 goroutine goready(gp, 3) } } 小结一下channel的关闭流程：
关闭一个nil channel 会panic 关闭一个已经关闭的channel会panic 把sendq和recvq 队列中的元素加入到 glist当中，清除所有sudog上所有未被处理的元素 最后把所有的阻塞的sudog全部唤醒，做一些扫尾工作 参考资料 【go语言的设计与实现】https://draveness.me/golang/ 【GitBook 码农桃花源开源书】https://qcrao91.gitbook.io/go/</content></entry><entry><title>Rich Content</title><url>/post/rich-content/</url><categories/><tags><tag>shortcodes</tag><tag>privacy</tag></tags><content type="html"> Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.
YouTube Privacy Enhanced Shortcode {{/&lt; youtube ZJthWmvUzzc >/}}
Twitter Simple Shortcode {{/&lt; twitter_simple 1085870671291310081 >/}}
Vimeo Simple Shortcode {{/&lt; vimeo_simple 48912912 >/}}
Bilibili Shortcode</content></entry><entry><title>图像占位符显示</title><url>/post/placeholder-text/</url><categories/><tags><tag>markdown</tag><tag>text</tag></tags><content type="html"> 范德格拉夫原理（Van de Graaf Canon）重构了曾经用于书籍设计中将页面划分为舒适比例的方法。这一原理也被称为“秘密原理”，用于许多中世纪的手稿和古板书中。在范德格拉夫原理中，文本区域和页面的长款具有相同的比例，并且文本区域的高度等于页面宽度，通过划分页面得到九分之一的订口边距和九分之二的切口边距，以及与页面长宽相同的比例的文本区域。
Vagus 示例 The Van de Graaf Canon 总结 当然设计中的黄金比例是为人所熟知的，黄金分割的公式为a:b=b:(a+b)。这是指较小的两个矩形与较大的两个矩形以相同的组合方式相关联。黄金分割比例为1:1.618。</content></entry><entry><title>数据公式设置显示</title><url>/post/math-typesetting/</url><categories/><tags/><content type="html"> Hugo 项目中的数学表示法可以通过使用第三方 JavaScript 库来实现。
在这个例子中，我们将使用 MathJax 创建一个文件 /content/en[zh-CN]/math.md
可以全局启用MathJax，请在项目配置中将参数math设置为true
或是在每页基础上启用MathJax，在内容文件中包括参数math: true
注意： 使用支持的TeX功能 的联机参考资料
例子 重复的分数 $$ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} \equiv 1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}} {1+\frac{e^{-8\pi}} {1+\cdots} } } } $$
总和记号 $$ \left( \sum_{k=1}^n a_k b_k \right)^2 \leq \left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right) $$
几何级数之和 我把接下来的两个例子分成了几行，这样它在手机上表现得更好。这就是为什么它们包含 \displaystyle。
$$ \displaystyle\sum_{i=1}^{k+1}i $$
$$ \displaystyle= \left(\sum_{i=1}^{k}i\right) +(k+1) $$
$$ \displaystyle= \frac{k(k+1)}{2}+k+1 $$
$$ \displaystyle= \frac{k(k+1)+2(k+1)}{2} $$
$$ \displaystyle= \frac{(k+1)(k+2)}{2} $$
$$ \displaystyle= \frac{(k+1)((k+1)+1)}{2} $$
乘记号 $$ \displaystyle 1 + \frac{q^2}{(1-q)}+\frac{q^6}{(1-q)(1-q^2)}+\cdots = \displaystyle \prod_{j=0}^{\infty}\frac{1}{(1-q^{5j+2})(1-q^{5j+3})}, \displaystyle\text{ for }\lvert q\rvert &lt; 1. $$
随文数式 这是一些线性数学: $$ k_{n+1} = n^2 + k_n^2 - k_{n-1} $$ ， 然后是更多的文本。
希腊字母 $$ \Gamma\ \Delta\ \Theta\ \Lambda\ \Xi\ \Pi\ \Sigma\ \Upsilon\ \Phi\ \Psi\ \Omega \alpha\ \beta\ \gamma\ \delta\ \epsilon\ \zeta\ \eta\ \theta\ \iota\ \kappa\ \lambda\ \mu\ \nu\ \xi \ \omicron\ \pi\ \rho\ \sigma\ \tau\ \upsilon\ \phi\ \chi\ \psi\ \omega\ \varepsilon\ \vartheta\ \varpi\ \varrho\ \varsigma\ \varphi $$
箭头 $$ \gets\ \to\ \leftarrow\ \rightarrow\ \uparrow\ \Uparrow\ \downarrow\ \Downarrow\ \updownarrow\ \Updownarrow $$
$$ \Leftarrow\ \Rightarrow\ \leftrightarrow\ \Leftrightarrow\ \mapsto\ \hookleftarrow \leftharpoonup\ \leftharpoondown\ \rightleftharpoons\ \longleftarrow\ \Longleftarrow\ \longrightarrow $$
$$ \Longrightarrow\ \longleftrightarrow\ \Longleftrightarrow\ \longmapsto\ \hookrightarrow\ \rightharpoonup $$
$$ \rightharpoondown\ \leadsto\ \nearrow\ \searrow\ \swarrow\ \nwarrow $$
符号 $$ \surd\ \barwedge\ \veebar\ \odot\ \oplus\ \otimes\ \oslash\ \circledcirc\ \boxdot\ \bigtriangleup $$
$$ \bigtriangledown\ \dagger\ \diamond\ \star\ \triangleleft\ \triangleright\ \angle\ \infty\ \prime\ \triangle $$
微积分学 $$ \int u \frac{dv}{dx},dx=uv-\int \frac{du}{dx}v,dx $$
$$ f(x) = \int_{-\infty}^\infty \hat f(\xi),e^{2 \pi i \xi x} $$
$$ \oint \vec{F} \cdot d\vec{s}=0 $$
洛伦茨方程 $$ \begin{aligned} \dot{x} &amp; = \sigma(y-x) \ \dot{y} &amp; = \rho x - y - xz \ \dot{z} &amp; = -\beta z + xy \end{aligned} $$
交叉乘积 这在KaTeX中是可行的，但在这种环境中馏分的分离不是很好。
$$ \mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \ \frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \ \frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \end{vmatrix} $$
这里有一个解决方案:使用“mfrac”类(在MathJax情况下没有区别)的额外类使分数更小:
$$ \mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \ \frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \ \frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \end{vmatrix} $$
强调 $$ \hat{x}\ \vec{x}\ \ddot{x} $$
有弹性的括号 $$ \left(\frac{x^2}{y^3}\right) $$
评估范围 $$ \left.\frac{x^3}{3}\right|_0^1 $$
诊断标准 $$ f(n) = \begin{cases} \frac{n}{2}, &amp; \text{if } n\text{ is even} \ 3n+1, &amp; \text{if } n\text{ is odd} \end{cases} $$
麦克斯韦方程组 $$ \begin{aligned} \nabla \times \vec{\mathbf{B}} -, \frac1c, \frac{\partial\vec{\mathbf{E}}}{\partial t} &amp; = \frac{4\pi}{c}\vec{\mathbf{j}} \ \nabla \cdot \vec{\mathbf{E}} &amp; = 4 \pi \rho \ \nabla \times \vec{\mathbf{E}}, +, \frac1c, \frac{\partial\vec{\mathbf{B}}}{\partial t} &amp; = \vec{\mathbf{0}} \ \nabla \cdot \vec{\mathbf{B}} &amp; = 0 \end{aligned} $$
这些方程式很狭窄。我们可以使用(例如)添加垂直间距 [1em] 在每个换行符(\)之后。正如你在这里看到的：
$$ \begin{aligned} \nabla \times \vec{\mathbf{B}} -, \frac1c, \frac{\partial\vec{\mathbf{E}}}{\partial t} &amp; = \frac{4\pi}{c}\vec{\mathbf{j}} \[1em] \nabla \cdot \vec{\mathbf{E}} &amp; = 4 \pi \rho \[0.5em] \nabla \times \vec{\mathbf{E}}, +, \frac1c, \frac{\partial\vec{\mathbf{B}}}{\partial t} &amp; = \vec{\mathbf{0}} \[1em] \nabla \cdot \vec{\mathbf{B}} &amp; = 0 \end{aligned} $$
统计学 固定词组：
$$ \frac{n!}{k!(n-k)!} = {^n}C_k {n \choose k} $$
分数在分数 $$ \frac{\frac{1}{x}+\frac{1}{y}}{y-z} $$
ｎ次方根 $$ \sqrt[n]{1+x+x^2+x^3+\ldots} $$
矩阵 $$ \begin{pmatrix} a_{11} &amp; a_{12} &amp; a_{13}\ a_{21} &amp; a_{22} &amp; a_{23}\ a_{31} &amp; a_{32} &amp; a_{33} \end{pmatrix} \begin{bmatrix} 0 &amp; \cdots &amp; 0 \ \vdots &amp; \ddots &amp; \vdots \ 0 &amp; \cdots &amp; 0 \end{bmatrix} $$
标点符号 $$ f(x) = \sqrt{1+x} \quad (x \ge -1) f(x) \sim x^2 \quad (x\to\infty) $$
现在用标点符号:
$$ f(x) = \sqrt{1+x}, \quad x \ge -1 f(x) \sim x^2, \quad x\to\infty $$</content></entry><entry><title>支持Emoji表情符号</title><url>/post/emoji-support/</url><categories/><tags><tag>emoji</tag></tags><content type="html"> Emoji 表情符号可以通过多种方式在 Hugo 项目中启用。
使用 Emoji 表情符号可以在模板中可以直接调用 emojify 函数或是通过 内联短代码 来实现。
如果要全局启用 Emoji 表情符号，请在网站配置 文件中将 enableEmoji 参数值设置为 true，然后可以直接在内容文件中输入表情符号简写代码，参考如下：
猴子表情 🙈 🙈 🙉 🙉 🙊 🙊 数字符号 1️⃣ 1️⃣ 2️⃣ 2️⃣ 3️⃣ 3️⃣ 建筑物 🏡 🏡 🏣 🏣 🏥 🏥 更多的 Emoji 表情符号代码可参考Emoji 配对目录 。
注意: 以上步骤在 Hugo 中启用 Unicode 标准表情符号和序列，但是这些符号的呈现取决于浏览器和平台，要设置表情符号的样式，您可以使用第三方表情符号字体或字体。例如：
.emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }</content></entry></search>