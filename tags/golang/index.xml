<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on 孤独前行</title><link>/tags/golang/</link><description>Recent content in golang on 孤独前行</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 15 Jan 2020 00:00:00 +0000</lastBuildDate><atom:link href="/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>grpc的简介和使用</title><link>/post/golang/grpc/</link><pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate><guid>/post/golang/grpc/</guid><description>gRPC(google+remote process call) 详解 grpc 简介 grpc是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。所谓RPC(remote procedure call 远程过程调用)框架实际是提供了一套机</description></item><item><title>GormV2-Mock单元测试</title><link>/post/golang/gorm-mock/</link><pubDate>Sun, 15 Apr 2018 00:00:00 +0000</pubDate><guid>/post/golang/gorm-mock/</guid><description>gorm v2 mock测试 平时开发中会经常用到各种数据库，做单元测试时又不想真正的连接数据库。今天介绍如何在基于gorm v2做单元测试 go-sqlmock 今天得主角就是</description></item><item><title>Etcd在go中的使用</title><link>/post/golang/etcd/</link><pubDate>Thu, 01 Mar 2018 00:00:00 +0000</pubDate><guid>/post/golang/etcd/</guid><description>Etcd 介绍 etcd 是一个高可用的分布式键值(key-value)存储数据库。具有以下特点: 简单：安装配置简单，而且提供了 HTTP API 进行交互，使用也很简单 键值</description></item><item><title>gotests单元测试</title><link>/post/golang/gotests/</link><pubDate>Thu, 15 Feb 2018 00:00:00 +0000</pubDate><guid>/post/golang/gotests/</guid><description>Go单元测试 go 程序中一般使用官方的go test 做测试，面对一些复杂情况和紧急需求写单元测试就变得有些仓促，今天介绍一款利器gotests来写单元测</description></item><item><title>GMP调度器简介</title><link>/post/golang/gmp/</link><pubDate>Sat, 10 Feb 2018 00:00:00 +0000</pubDate><guid>/post/golang/gmp/</guid><description>GO 语言的调度器 目录 GMP 模型简介 调度器实现机制 GMP 模型简介 先来一张经典的GMP 关系图 G 是go程序中调度器中的一个任务，类似操作系统中的线程，主要处</description></item><item><title>Go Channel 底层实现</title><link>/post/golang/go-channel/</link><pubDate>Thu, 01 Feb 2018 00:00:00 +0000</pubDate><guid>/post/golang/go-channel/</guid><description>Go Channel 底层实现 目录 channel 是什么 channel 的创建 channel 的发送 channel 的接收 channel 的关闭 channel 是什么 “Do not communicate by sharing memory; instead, share memory by communicating.” 不要通过共享内存通信，</description></item></channel></rss>